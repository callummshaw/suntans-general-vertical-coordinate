48,49d47
< static void CorrectorTmp(REAL **qc, REAL **u, REAL **w, gridT *grid, physT *phys, propT *prop, int myproc, 
<     int numprocs, MPI_Comm comm);
52d49
< static void DivergenceCheck(REAL **src, REAL **u, REAL **w, gridT *grid, physT *phys, propT *prop, int myproc, int numprocs);
137d133
<   (*phys)->divtmp_u = (REAL **)SunMalloc(Ne*sizeof(REAL *),"AllocatePhysicalVariables");
171d166
<     (*phys)->divtmp_u[j] = (REAL *)SunMalloc(grid->Nkc[j]*sizeof(REAL),"AllocatePhysicalVariables");
198d192
<   (*phys)->divtmp = (REAL *)SunMalloc(Nc*sizeof(REAL),"AllocatePhysicalVariables");
214d207
<   (*phys)->divtmp_w = (REAL **)SunMalloc(Nc*sizeof(REAL *),"AllocatePhysicalVariables");
235d227
<   (*phys)->divtmp_src = (REAL **)SunMalloc(Nc*sizeof(REAL *),"AllocatePhysicalVariables");
293d284
<     (*phys)->divtmp_w[i] = (REAL *)SunMalloc((grid->Nk[i]+1)*sizeof(REAL),"AllocatePhysicalVariables");
323d313
<     (*phys)->divtmp_src[i] = (REAL *)SunMalloc(grid->Nk[i]*sizeof(REAL),"AllocatePhysicalVariables");
437d426
<     free(phys->divtmp_u[j]);
454d442
<     free(phys->divtmp_w[i]);
482d469
<     free(phys->divtmp_src[i]);
506d492
<   free(phys->divtmp_w);
518d503
<   free(phys->divtmp_src);
547d531
<   free(phys->divtmp_u);
1301c1285
<   
---
> 
1311c1295
<   
---
> 
1341,1342d1324
<   if(prop->vertcoord!=1 && prop->vertcoord!=5)
<     TvdFluxHeight(grid, phys, prop, vert->dzfmeth,comm, myproc);
1486,1487d1467
<       if(prop->vertcoord!=1 && prop->vertcoord!=5)
<         TvdFluxHeight(grid, phys, prop, vert->dzfmeth,comm, myproc);
1526d1505
< 
1687c1666,1667
<         // Wpredictor calculate w^*
---
> 
>          // Wpredictor calculate w^*
1743,1749c1723,1725
<         LayerAveragedContinuity(vert->omega,grid,prop,phys,myproc);
<         ISendRecvWData(vert->omega,grid,myproc,comm);
<         Continuity(phys->w,grid,phys,prop);
<         ISendRecvWData(phys->w,grid,myproc,comm);
<         // w_im is calculated
<         //Continuity(phys->w,grid,phys,prop);
<         //ISendRecvWData(phys->w,grid,myproc,comm);
---
>         //LayerAveragedContinuity(vert->omega,grid,prop,phys,myproc);
>         //ISendRecvWData(vert->omega,grid,myproc,comm);
> 
1764c1740
<   
---
> 
1769,1772c1745
<        //for(i=0;i<grid->Nc;i++)
<         //for(k=0;k<grid->Nk[i];k++)
<           //if(vert->dzdx[i]!=0)
<             //printf("i %d k %d dzdx %e\n",i,k,vert->dzdx[i][k]);
---
> 
2131,2134d2103
<         if(nc1==-1)
<           nc1=nc2;
<         if(nc2==-1)
<           nc2=nc1;
2624a2594
> 
2756c2726
<         phys->Cn_W[i][k]=phys->Cn_W2[i][k]=0;
---
> 	phys->Cn_W[i][k]=phys->Cn_W2[i][k]=0;
2765a2736
> 
3135,3160d3105
< static void CorrectorTmp(REAL **qc, REAL **u, REAL **w, gridT *grid, physT *phys, propT *prop, int myproc, 
<     int numprocs, MPI_Comm comm)
< {
< 
<   int i, iptr, j, jptr, k;
< 
<   // Correct the horizontal velocity only if this is not a boundary point.
<   // no boundary points are corrected for non-hydrostatic pressure!!!
<   for(jptr=grid->edgedist[0];jptr<grid->edgedist[1];jptr++) {
<     j = grid->edgep[jptr]; 
<     if(phys->D[j]!=0 && grid->etop[j]<grid->Nke[j]-1)
<       for(k=grid->etop[j];k<grid->Nke[j];k++)
<         u[j][k]=phys->u[j][k]-prop->dt/grid->dg[j]*
<           (qc[grid->grad[2*j]][k]-qc[grid->grad[2*j+1]][k]);
<   }
<   // Correct the vertical velocity
<   for(iptr=grid->celldist[0];iptr<grid->celldist[1];iptr++) {
<     i = grid->cellp[iptr]; 
<     for(k=grid->ctop[i]+1;k<grid->Nk[i];k++)
<       w[i][k]=phys->w[i][k]-2.0*prop->dt/(grid->dzz[i][k-1]+grid->dzz[i][k])*
<         (qc[i][k-1]-qc[i][k]);
<     w[i][grid->ctop[i]]=phys->w[i][grid->ctop[i]]+2.0*prop->dt/grid->dzz[i][grid->ctop[i]]*
<       qc[i][grid->ctop[i]];
<   }
< }
< 
3247,3296d3191
< 
< static void DivergenceCheck(REAL **src, REAL **u, REAL **w, gridT *grid, physT *phys, propT *prop, int myproc, int numprocs) 
< {
<   int i, iptr, j, jptr, k, nf, ne, nc1, nc2;
<   REAL fac1,fac2,fac3,flux;
< 
<   // new implicit method
<   fac1=prop->imfac1;
<   fac2=prop->imfac2;
<   fac3=prop->imfac3;
<  
<   // for each cell
<   for(i=0;i<grid->Nc;i++)
<     // initialize to zero
<     for(k=grid->ctop[i];k<grid->Nk[i];k++) 
<       src[i][k] = 0;
< 
<   // for each computational cell
<   for(iptr=grid->celldist[0];iptr<grid->celldist[1];iptr++) {
<     // get the cell pointer
<     i = grid->cellp[iptr];
<     /* VERTICAL CONTRIBUTION */
<     // over all cells that are defined to a depth
<     for(k=grid->ctop[i];k<grid->Nk[i];k++) {
<       // compute the vertical contributions to the source term
<       if(!prop->subgrid)
<         src[i][k] = grid->Ac[i]*fac1*(w[i][k]-w[i][k+1])
<            +fac2*grid->Ac[i]*(phys->w_old[i][k]-phys->w_old[i][k+1])+fac3*grid->Ac[i]*(phys->w_old2[i][k]-phys->w_old2[i][k+1]);
<       else
<         src[i][k] = fac1*(subgrid->Acveff[i][k]*w[i][k]-subgrid->Acveff[i][k+1]*w[i][k+1])
<           +fac2*(subgrid->Acveffold[i][k]*phys->w_old[i][k]-subgrid->Acveffold[i][k+1]*phys->w_old[i][k+1])
<           +fac3*(subgrid->Acveffold2[i][k]*phys->w_old2[i][k]-subgrid->Acveffold2[i][k+1]*phys->w_old2[i][k+1]);
<     }
< 
<     /* HORIZONTAL CONTRIBUTION */
<     // over each face to get the horizontal contributions to the source term
<     // no change is needed for the new generalized vertical coordinate
<     for(nf=0;nf<grid->nfaces[i];nf++) {
<       // get the edge pointer
<       ne = grid->face[i*grid->maxfaces+nf];
<       // for each of the defined edges over depth
<       for(k=grid->ctop[i];k<grid->Nke[ne];k++) 
<         // compute the horizontal source term via the (D_H)(u^*)
<         src[i][k]+=(fac1*u[ne][k]+fac2*phys->u_old[ne][k]+fac3*
<           phys->u_old2[ne][k])*grid->dzf[ne][k]*grid->normal[i*grid->maxfaces+nf]*grid->df[ne];
<     }
<   }
< }
< 
< 
3315c3210
<   REAL **x, **r, **rtmp, **p, **z, mu, nu, alpha, alpha0, eps, eps0,divtmp;
---
>   REAL **x, **r, **rtmp, **p, **z, mu, nu, alpha, alpha0, eps, eps0;
3421,3426d3315
<     //ISendRecvCellData3D(x,grid,myproc,comm);    
<     // calculate local continuity form
<     //CorrectorTmp(x, phys->divtmp_u, phys->divtmp_w, grid, phys, prop,myproc, numprocs,comm);
<     //DivergenceCheck(phys->divtmp_src, phys->divtmp_u,phys->divtmp_w, grid, phys, prop, myproc, numprocs);
<     //divtmp=sqrt(InnerProduct3(phys->divtmp_src,phys->divtmp_src,grid,myproc,numprocs,comm));
<    
3428,3441c3317,3319
<     //printf("n %d iter %d divtmp %e\n",prop->n,n,divtmp );
<     if(VERBOSE>2 && myproc==0) printf("CGSolve Pressure Iteration: %d, resid=%e\n",n,sqrt(eps/eps0));
<    
<     //if(eps0<=1)
<       if(sqrt(eps/eps0)<prop->qepsilon) {
<         printf("n %d iter %d divtmp %e eps0 %e eps %e\n",prop->n,n,divtmp,eps0,eps);
<         break;
<       }
<     /*if(eps0>1){
<       if(sqrt(eps)<prop->qepsilon) {
<         printf("n %d iter %d divtmp %e eps0 %e eps %e\n",prop->n,n,divtmp,eps0,eps);
<         break;
<       }  
<     } */   
---
>     if(VERBOSE>3 && myproc==0) printf("CGSolve Pressure Iteration: %d, resid=%e\n",n,sqrt(eps/eps0));
>     if(sqrt(eps/eps0)<prop->qepsilon) 
>       break;
3463,3464d3340
< 
< 
3595,3596c3471,3472
<     def1 = grid->def[nc1*grid->maxfaces+grid->gradf[2*j]];
<     def2 = grid->def[nc2*grid->maxfaces+grid->gradf[2*j+1]];
---
>     def1=sqrt(pow(grid->xv[nc1]-grid->xe[j],2)+pow(grid->yv[nc1]-grid->ye[j],2));
>     def2=grid->dg[j]-def1;
3689c3565
<           d[k] =(l1*vert->omega_old[n0][k]+l0*vert->omega_old[n1][k])/(l1+l0);
---
>           d[k] =(l1*vert->omega_old[n0][k]+l0*vert->omega_old[n1][k])/grid->dg[j];
3853c3729
<             (def1+def2)/(0.5*(grid->dzz[nc1][k]+grid->dzz[nc2][k]));
---
>             grid->dg[j]/(0.5*(grid->dzz[nc1][k]+grid->dzz[nc2][k]));
4025c3901
<             (def1+def2)/(0.5*(grid->dzz[nc1][k]+grid->dzz[nc2][k]));         
---
>             grid->dg[j]/(0.5*(grid->dzz[nc1][k]+grid->dzz[nc2][k]));         
4584d4459
< 
4587d4461
< 
5911,5913c5785,5790
<   def1 = grid->def[nc1*grid->maxfaces+grid->gradf[2*j]];
<   def2 = grid->def[nc2*grid->maxfaces+grid->gradf[2*j+1]];
<   Dj=def1+def2;
---
> 
>   Dj = grid->dg[j];
> 
>   def1 = sqrt(pow(grid->xv[nc1]-grid->xe[j],2)+
>       pow(grid->yv[nc1]-grid->ye[j],2));
>   def2 = Dj-def1;
5939,5941c5816,5820
<   def1 = grid->def[nc1*grid->maxfaces+grid->gradf[2*j]];
<   def2 = grid->def[nc2*grid->maxfaces+grid->gradf[2*j+1]];
<   Dj=def1+def2;
---
>   Dj = grid->dg[j];
>   def1 = sqrt(pow(grid->xv[nc1]-grid->xe[j],2)+
>       pow(grid->yv[nc1]-grid->ye[j],2));
>   def2 = Dj-def1;
> 
5943,5944c5822,5823
<   if(method==2) C = 0;
<   if(def1==0 || def2==0 || method==1) {
---
> 
>   if(def1==0 || def2==0) {
6065,6071c5944
<       if(prop->vertcoord!=1 && prop->vertcoord!=5){
<         if(grid->mark[j]==0)
<           if(phys->u[j][k]>0)
<             grid->dzf[j][k]=phys->SfHp[j][k];
<           else
<             grid->dzf[j][k]=phys->SfHm[j][k];
<       }
---
> //      grid->dzf[j][k]=UFaceFlux(j,k, grid->dzz, phys->u, grid,prop->dt,prop->nonlinear);
6578,6580c6451,6455
<   def1 = grid->def[nc1*grid->maxfaces+grid->gradf[2*j]];
<   def2 = grid->def[nc2*grid->maxfaces+grid->gradf[2*j+1]];
<   Dj=def1+def2;
---
>   Dj = grid->dg[j];
>   def1 = sqrt(pow(grid->xv[nc1]-grid->xe[j],2)+
>       pow(grid->yv[nc1]-grid->ye[j],2));
>   def2 = Dj-def1;
> 
6745c6620
< }
---
> }
\ No newline at end of file
